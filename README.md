# Microsoft Malware Detection

## Overview

This repository contains the code and documentation for detecting and classifying malware using machine learning techniques. The project is structured to guide users through data preprocessing, feature extraction, model training, and evaluation, leveraging a dataset provided by Microsoft.

## Table of Contents

- [Overview](#overview)
- [Table of Contents](#table-of-contents)
- [Type of Model Used](#type-of-model-used)
- [Workflow](#workflow)
- [Conclusion](#conclusion)

## Type of Model Used

The following machine learning models are utilized in this project:
- XGBoost

## Workflow

1. With the assignment, we were given two sets of files: `result_x` and `result_y` (classes), and a target score of 0.01 or less to achieve.
2. Creating byte-bigram features was a critical step.
   - Acquired a system with 16 GB RAM and an Intel Core i7 processor.
   - Used Anaconda packages to manage dependencies.
   - Due to the large number of files, multiprocessing was required. However, Python packages for multiprocessing could not fully utilize the system's RAM and CPU cores on Windows.
   - As a workaround, multiple Jupyter notebooks were run on different sets of files. This took around 3 hours and resulted in a 1.6 GB CSV file with 66,050 features after merging.
3. Based on the 'dchad' presentation, byte/asm files were converted to image files, generating another 2,000 features.
4. Due to its sparsity, The `byte-bigram.csv` file was too large to load into memory.
5. Various attempts (size reduction with PCA, SVD, feature importance, permutation importance, or direct split, convert, and merge) to change the byte-bigram files (1.6 GB sparse file) into a sparse `coo_matrix` failed as even 25 GB RAM (Colab) couldn't handle the memory load. The acquired PC was no longer available to recreate the sparse matrix.
6. Intense hyperparameter tuning (e.g., two-step grid search, zooming in on the search space on singular features, Optuna, Bayesian search methods) was performed to strike the perfect balance between variance and bias using only the provided files and image features, achieving a score of 0.0089 on the test files.

| S.NO. | Architecture                                    | Test Logloss |
|-------|-------------------------------------------------|--------------|
| 1     | n_estimators = 90, depth = 6, lr = 0.01         | 0.0102       |
| 2     | n_estimators = 100, depth = 10, lr = 0.02       | 0.0140       |
| 3     | n_estimators = 100, depth = 3, lr = 0.015       | 0.0089       |

## Conclusion

The project successfully demonstrates how to detect and classify malware using machine learning. By leveraging various models and extensive hyperparameter tuning, we achieved a test log loss of 0.0089, surpassing the target score of 0.01. The methodologies and strategies applied in this project can be useful for similar tasks in malware detection and classification.
